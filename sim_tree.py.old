#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Dec 14 18:28:31 2022
this simulates tree to find number of non-zero path. 
It DOES  STORE the matrices u,s,v in each node: 
that is why it is slow! 
@author: adaskin
"""
import  numpy as np
import  matplotlib.pyplot as plt


def qft(N):
    '''
    generates quantum fourier transform matrix of dimension N=2^n
    N: dimension
    '''
    w = np.exp(2*np.pi*1j/N)
    A = np.zeros([N,N], dtype='complex')
    for i in range(0, N):
        for j in range(0, N):
            A[i,j] = w**(j*i)/N
    print("shape of A:", A.shape)
    return A

def find_childs(avec):
    if avec.size <= 2: 
        return avec;
    A = avec.reshape(2, int(avec.size/2))
    #print("shape of A:", A.shape, A.size)
    u, s, v = np.linalg.svd(A,full_matrices=False)
      

    return u,s,v


def generate_tree_elements(avec):
    ''' 
    generates Schmidt decomp tree
    returns a list of u, s,v, sprev and number of nonzeropath
    sprev: the prob along the path
    '''
    N =  avec.size
    if N <= 2: 
        return avec;  
    nonzeropath = 0
    #list of (u,s,v)
    usv_tree = [0]*N
    level = 0 
    u,s,v = find_childs(avec)

    #left child, sprev is the combination of schmidt coeff along the path
    sprev = s[0]
    usv_tree[1] = (u[0],s[0],v[0], sprev)
    #right child, sprev is the combination of schmidt coeff along the path
    sprev = s[1]
    usv_tree[2] = (u[1],s[1],v[1], sprev)
    while(v.shape[1] > 2): #level child id
        level += 1
        istart = 2**(level)-1
        iend = istart+2**(level)
        inode = iend
        for i in range(istart, iend):
            # sprev is the combination of schmidt coefficients along the path
            sprev = 0
            if type(usv_tree[i]) != int:
                sprev = usv_tree[i][3]

            if sprev > 0.00001: #if prob is too small, skip
                u,s, v = find_childs(usv_tree[i][2])
                #left child, 
                usv_tree[inode] = (u[0], s[0], v[0], sprev*s[0])
                #rightchild
                usv_tree[inode+1] = (u[1], s[1], v[1],sprev*s[1])
                if v.shape[1] == 2:
                    nonzeropath += 1
            print("svd node:{}, addnodes:{},{}"
                .format(i, inode, inode+1))
            inode += 2 
            
    return usv_tree, nonzeropath

def generate_tree_elements_with_compression(avec):
    ''' 
    generates Schmidt decomp tree
    returns a list of u, s,v, sprev and number of nonzeropath
    sprev: the prob along the path
    '''
    N =  avec.size
    if N <= 2: 
        return avec;  
    nonzeropath = 0
    #list of (u,s,v)
    usv_tree = [0]*N
    level = 0 
    u,s,v = find_childs(avec)

    #left child, sprev is the combination of schmidt coeff along the path
    sprev = s[0]
    usv_tree[1] = (u[0],s[0],v[0], sprev)
    #right child, sprev is the combination of schmidt coeff along the path
    sprev = s[1]
    usv_tree[2] = (u[1],s[1],v[1], sprev)
    while(v.shape[1] > 2): #level child id
        level += 1
        istart = 2**(level)-1
        iend = istart+2**(level)
        inode = iend
        for i in range(istart, iend):
            # sprev is the combination of schmidt coefficients along the path
            sprev = 0
            if type(usv_tree[i]) != int:
                sprev = usv_tree[i][3]

            if sprev > 0.000001: #if prob is too small, skip
                u,s, v = find_childs(usv_tree[i][2])
                #left child, 
                usv_tree[inode] = (u[0], s[0], v[0], sprev*s[0])
                #rightchild
                usv_tree[inode+1] = (u[1], s[1], v[1],sprev*s[1])
                if v.shape[1] == 2:
                    nonzeropath += 1
            print("svd node:{}, addnodes:{},{}"
                .format(i, inode, inode+1))
            inode += 2 
        
        nsame = tree_prefix_compression(usv_tree, istart, iend)
        print("compressed nodes in level: {}, #nodes:{}".format(level, nsame))

    return usv_tree, nonzeropath

def tree_prefix_compression(usv_tree, istart, iend):
    '''
    compare the prefixes us, of the childs in the same level, 
    and compress them into vi+vj
    istart: start index of the usv_tree[node]
    iend: end index of the usv_tree[node]
    '''
    nsame = 0
    for i in range(istart, iend-1):
        if isinstance(usv_tree[i], tuple):
            ui,si, vi, sprevi = usv_tree[i]
            for j in range(i+1, iend):
                if isinstance(usv_tree[j], tuple):
                    uj,sj, vj, sprevj = usv_tree[j]  
                    if(np.abs(sprevj-sprevi)<0.00001 
                        and np.linalg.norm(ui-uj)<0.001):
                         print("the same prefixed neighbors,",i,j, usv_tree[i][2].size)
                    if(np.linalg.norm(vi-vj) < 0.01):
                        '''same suffix'''
                            #and np.linalg.norm(vi-vj) <0.01):
                        print("the same neighbors,",i,j, usv_tree[i][2].size)
                        nsame += 1
    return nsame





def compare_childs(usv_tree):
    '''
    find the same s, u elements in non-zero paths
    '''
    level = 0 
    N = len(usv_tree)
    ntotal = 0
    for level in range(1, int(np.log2(N))): #level child id
        istart = 2**(level)-1
        iend = istart+2**(level)
        nsame = 0
        print("level:{},  ".format(level))
        for i in range(istart, iend-1):
            if isinstance(usv_tree[i], tuple):
                ui,si, vi, sprevi = usv_tree[i]
                for j in range(i+1, iend):
                    if isinstance(usv_tree[j], tuple):
                        uj,sj, vj, sprevj = usv_tree[j]  
                        if(np.abs(sprevi*si-sprevj*sj) < 0.0001 
                            and np.linalg.norm(ui-uj) < 0.01):
                                #and np.linalg.norm(vi-vj) <0.01):
                            print("the same neighbors,",i,j)
                            nsame += 1
        ntotal += nsame
        
    return ntotal



n =6
N = 2**n
psi = 0
scase = 1
sprev = 1
n0path = 0
Nsquare = N**2
if scase == 1:#qft
    A = qft(N)
    a = A.flatten()
    psi = a
elif scase == 2:#random
    b = np.random.randn(1,N)
    b = b/np.linalg.norm(b)
    psi = b
else:#grover-like
    c =  np.eye(N,N).flatten()/np.sqrt(N)
    c[-1] = -c[-1]
    psi = c

listofdecomps = np.array([3,N,N], dtype=complex)

print('=================================================================\n\n')
(usv_tree, nonzeropath) = generate_tree_elements(psi)

L = []
for i in range(int(len(usv_tree)/2)+1, len(usv_tree)):
    if isinstance(usv_tree[i], tuple):
        L.append(usv_tree[i][3])
    else:
        L.append(0)
fig, ax = plt.subplots()

values, bins, bars = ax.hist(L)

ax.set_xlabel("probability (coefficient) of the path")
ax.set_ylabel("Number of paths")
ax.set_title('n:{}-qubits '.format(n))
ax.bar_label(bars, fontsize=9, color='red')

